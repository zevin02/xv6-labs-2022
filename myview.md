
# lazy allocation
sbrk调用完全不会去开辟内存，只需要将p->sz增加到p->sz+n即可,在之后应用程序使用到这个内存，就会触发一个page fault，
>因为我们没有把p->sz+n处分配物理内存，
>此时，我们解析到的是>p->sz,< p->sz+n
>所以我们这个时候才需要内核去分配内存，后重新执行指令

>我们发现当前的地址小于p->sz,同时又大于stack的时候，他就是在heap上的地址
 
* 处理方法
>1. kalloc()开辟一个内存page，物理空间
>2. 将新开辟的物理空间置0
>3. 将出错的va映射到用户的页表中，和其物理地址相对应
>4. 继续执行原来的指令(sepc)

Q：使用lazy alloc应用程序怎么知道已经没有物理内存了(OOM(out of memory))
A: 返回一个杀掉的进程，直接杀掉,一般操作系统也会处理的比较聪明，但是如果实在找不到可以是使用的内存，OS还是会杀掉这个进程

## sbrk
int sbrk(int);
>sbrk里面的参数就是我们需要增加或者减少的字节大小
>sbrk的返回值就是在调用sbrk改变内存空间大小之前的内存字节数

Q: 我并不能理解为什么在uvmunmap中可以直接改成continue？
~~~c
void
uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
{
  uint64 a;
  pte_t *pte;

  if((va % PGSIZE) != 0)
    panic("uvmunmap: not aligned");

  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
    if((pte = walk(pagetable, a, 0)) == 0)
      panic("uvmunmap: walk");
    if((*pte & PTE_V) == 0)
    continue;
    ...
  }
}
~~~
>uvmunmap这个函数就是用来取消映射的，do_free参数就是可以顺便把该处对应的物理内存给删除掉

>* 因为我们在调用sbrk的时候只是增加了p->sz，但是并没有实际的开辟物理内存，进行对应，同样也没有把那块空间进行映射
>* 同理，这块空间也不能释放，页不能沟取消映射，因为这些操作我们在调用sbrk的时候，根本就没有执行

>但是对于没有修改之前的xv6,出现是一定要panic的，因为我们所以的空间都是有开辟进行对应的


# Zero Fill On Demand
按需置零

在用户进程地址空间中，有text区（存放程序的指令），data区（存放以初始化的变量），BSS区（存放未被初始化的变量）

我们在虚拟地址上的BSS区，只需要在物理内存中分配一个page，把bss区一开始都先映射到那一块的**0区域page**,这样可以节省大量的内存，我们在使用页表映射的时候，设置的都是R权限 
如果我们向BSS区进行写入的话，就会生成一个`page fault`,

处理方法
---
>1. 在物理内存开辟空间,一块新的page
>2. 把里面的内容设置为0
>3. 更新va和物理page之间的映射关系
>4. 将pte设置为可读可写

好处

1. 可以减少内存的使用，我们只在需要的时候才会申请内存
2. exec工作变少，所有的BSS虚拟的page都可以映射到内容全为0的page上面

# Copy On Write Fork
shell中要执行一些命令，`fork`会创建对shell进程的一个拷贝，而fork出来的子进程要执行程序，都是需要`exec`，如`echo`，

<u>而执行exec就是要的丢弃我们fork出来的地址，用echo地址进行取代</u>

>* 每次创建一个进程的时候，就会在物理内存分配出4个page，同理在子进程fork出来之后也要给他在物理内存上开辟4个page，
>* 这里我们可以进行一个优化，在fork子进程的时候不需要在物理内存上创建一个新的page，只需要把子进程的同样映射到副进程对应的物理内存中即可

>为了确保父子进程的隔离性，我们应该把他的权限设置为只读，避免父子进程都在修改某个地方造成混乱

>如果某个时刻，父/子进程修改其中的内容的时候，就会触发一个page fault,假如现在是子进程进行修改

<u>解决方案</u>

* 我们需要把被父子进程此时共享的物理页表设置成`W`
* 把子进程映射到的那个位置`取消映射绑定`,uvmunmap,这里也需要把引用计数-1,因为这个地方页调用了`kfree` 
* 子进程需要重新<u>创建一块物理空间</u>,将父进程的冲突的物理空间给**拷贝**过去，`memmove`
* 子进程把此时冲突的va进行映射到新开辟的物理空间上面,建立新的映射`kalloc`,`mappaging`
* 把新开辟的物理页表也设置成`W`
* 为了避免一个物理页表会被多个进程所共享，我们增加了一个`引用计数`的机制
* 调用`kalloc`开辟空间的时候把该物理地址对应的引用计数设置为**1**
* 调用`kfree`释放物理地址的时候，就把该物理地址对应的引用计数**-1**，如果引用计数为0,才会把地方对应的物理空间给释放掉
* 调用`fork`的时候，就把那个地方对应的引用计数**+1**
* 



# Demand Paging
<u>按需置页</u>

在`fork`创建子进程之后就会调用`exec`，进行替换fork拷贝父亲进程的地址空间，用exec的进程地址空间

加载到内存的有包括`text`，和`data`区域，我们现在不会再把所有的数据直接全部都加载内存里面，而是**按需分配**，使用到了才会分配内存

程序是从地址为0x00的地方开始运行，向上增长，会从最底处的地址触发<u>page fault</u>（没有加载到内存）

>我们需要从程序文件中读取数据，再将内存page映射到page table上面，最后返回执行指令

* 如果内存使用完了怎么办？
LRU（least recently used）
>我们可以把一个pte_a|pte_d没有被设置的page进行替换，撤回这个page，加载新page，使用这个page给page fault进行使用


