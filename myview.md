注意 
> 一个pagetable一共于是有4096个字节，每一个条目就是一个地址，每个地址就是一个指针，都是8字节
所以一个pagetable就是有512个条目，存储512个地址

# speed up syscall
1. 对于获取一个进程的状态，我们就可以将内核态暴露给用户态，添加一个pte_u选项，这样用户态就能使用了，可以加速系统调用的执行
2. 但是我们不能用这个进程的系统调用去读取其他进程的状态
3. 

# print pagetable
1. 解释下列的列表打印的输出
~~~c
page table 0x0000000087f6b000
 ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000
 .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000
 .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000
 .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000
 .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000
 .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000
 ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000
 .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
 ~~~
我们能够从内核地址空间中可以查看这些虚拟地址，以及这些条目都代表什么意思，

* what is entry 0, 1, 2, and 3?
>1. 0号条目是虚拟地址的最底端，一帮都是text
>2. 1号条目data
>3. 2号条目是guard（一般就是stack下的保护页，避免stack向下增长溢出造成错误）
>4. 3号条目就是stack

* what is 509, 510, and 511?
>1. 509是USYCALL这个是在内核上的，地址就比较高,flag(URV),因为这个就是给用户进行加速系统调用使用的，所以肯定是有 U bit
>2. 510就是trapframe，这个一般就是在这个条目，里面保存着所有trap的数据，FLAG（WRV），这个只能系统进行操作，读写，用户无法进行读写修改
>3. 511就是trampoline，这个再所有的地方都映射再同一个地址，所以再trap的时候也不会出现错误，flag（XRV），这个就是因为我们再trap的时候需要执行这些代码

* why are XRW = 0 in L0 and L1 ptes?
>我们对上面的进行操作，发现l0,和l1的那些pte的xrw位都等于0,这是因为他们都不是最后一个pte，只有最后一个pte（叶子pte），他们的flag标志位才是最终有效的


* why can we use the output of PTE2PA as a virtual address?
>pte2pa这个就是把在页标里面获得的一个pte，将这个pte的值向左移动12位就是pa的值、
>pa就是取pte的44位，再取va虚拟地址的最后的12位offset


# access
>* 如果pte中`pte_a`标记位被设置的话，说明这个pte之前已经被访问过（`read` or `write`）了，我们发现之后再把这个标记位给取消掉即可
>* 如果pte中`pte_d`标记位被设置的话，说明这个pte对应的page已经被写过了

>这个题就是在用户的页表中查看有几个（最多是len个，我们需要在这里读取参数）pte已经被访问过了（a标志位是系统会自动帮我们设置的），我们需要查看的就是这个起始页上有多少个虚拟的地址被设置了

>1. 这里的第一个参数就是第一个用户进程空间虚拟地址的起始位置
>2. 这里的第二个参数就是需要检查多少个page
>3. 把检查出来第几个page，写在位图里面，返回给用户态即可




