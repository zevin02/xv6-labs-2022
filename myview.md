 thread switch
# 线程切换的步骤
1. 获得自己进程的锁
2. 将state 设置从running-> runable
3. switch切换到该cpu的调度期线程
4. 调度器线程之前也使用了switch，所以我们现在会恢复到该调度器线程调用switch的地方
5. 返回后，调度期线程会释放刚刚cpu上的锁

## 获得锁的原因：
避免在设置从running到runable的时候，有其他调度器线程发现了这个runable，并切换到该线程
但是当前线程在设置之后，还没switch到对应的调度器线程上，此时其他cpu的调度期线程切换过来，造成两个cpu在同一个栈上运行

Q： 多个cpu核能看到同一个锁，因为他们共享了相同物理内存系统

## 不能持有其他的锁
在线程切换的时候，必须持有p->lock（只能持有自己的锁）
>线程切换如果持有了p->lock以外的锁，如（uart，console）
* 在拥有这个锁后，进行内核切换，让出CPU
* 切换到调度机器线程后p仍然持有这个锁，之后让p停止运行，就会导致p一直持有着锁，
* 调度期线程切换到另一个线程，p2也向使用uart，就会索要这个锁，但是被p1持有
* 就赵成了死锁

所以我们在这里面禁止了除了自己的锁外还有其他的锁

~~~c
void
sched(void)//这些代码都是用来检察的，最重要的就是swtch
{
  int intena;
  struct proc *p = myproc();
    ...
    panic("sched p->lock");
  if(mycpu()->noff != 1)//我们希望有锁,但是我们只希望持有1把自己的锁，如果还持有其他的锁的话，直接就panic即可
    panic("sched locks");
    ...
}
~~~

> 这个时候我们无法通过发生定时器中断而解除死锁
> 因为我们在持有锁的时候，是把定时器给关掉的，所以无法发生中断
> 但是按道理来说是可以的，在发生计时器中断的时候解除锁


# sleep & wakeup

条件变量
条件变量就是等待条件成立在获得锁
1. 在管道读数据，要等到管道非空的条件 
2. 在读取磁盘的时候，等待读取磁盘结束的条件
3. wait函数，就是进程等待任何一个子进程退出的条件
